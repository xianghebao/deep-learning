js采用单线程工作模式，js执行环境中负责执行代码的线程只有一个
优点：安全简单， 
缺点：若有一个非常耗时的任务，那么后面所有的任务都要等待前面的任务执行完毕，

js为了解决上述这种阻塞问题，js将任务的执行模式分成了两种，分别是 同步模式和异步模式

主要学习要点：
	1.同步模式与异步模式
	2. js的单线程是如何实现的异步模式，即事件循环和消息队列
	3. 异步编程的几种方法
	4. promise异步方案，宏任务/微任务队列
	5. Generator异步方案，async/await 语法糖


同步模式 ：排队执行
执行栈
	开始执行，js执行引擎会把所有的代码加载进来，然后在调用栈中加入一个匿名调用，可以理解为把所有的代码加入到匿名函数中去执行，然后逐行执行代码，
当遇到执行的函数函数是将其放入调用栈中，函数执行完毕移出调用栈，当所有的代码执行完毕，这个调用栈（匿名函数调用）就会被清空掉


异步模式： 不会等待这个任务结束才开始下一个任务，开启过后就会立即往后执行下一个任务，后续逻辑一般会通过回调函数的方式定义
	缺点（问题）： 代码的执行顺序混乱
执行栈，webapis 事件循环和消息队列(回调队列)

总结：
js是单线程的，但是浏览器不是单线程的，更具体一些我们通过js调用的某些api 并不是单线程的，例如计时器

回调函数：js中实现异步编程的根本方式，所有的异步编程方案的根本都是回调函数。


promise ：是一种更优的异步编程统一规范
promise是一个对象，用来去表示一个异步任务最终结束后，结果是成功还是失败
promise 开始是一个待定的状态，状态结束后会有成功或失败的结果，而且一旦明确了结果过后不可发生改变

promise 常见误区
	在.then函数里面再次写回调函数，同样会形成回调地狱， 要使用promise链式调用，即在上一个.then中 返回一个相关值

闭包本质： 
	函数在执行的时候会放到一个执行栈上，当函数执行完毕后会从执行栈移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员
 

纯函数：相同的函数都会有相同的输出

柯里化：当一个函数有多个参数的时候我们可以给这个函数进行改造，首先调用一个函数只传递部分的参数，并且让这个函数返回一个新的函数，新的函数可以接收剩余的参数，并且返回相应的结果，这就是柯里化。
即 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）；然后返回一个新的函数接收剩余的参数

函子（Functor）
	学习函子的目的 ：将函数式编程的副作用控制在可控范围内
什么是函子：
	容器：包含值和值的变形关系（变形关系就是函数）
	函子：是一个特殊的容器，通过一个普通的对象实现，该对象具有map方法，map方法可以运行一个函数对值进行处理（变形关系）	
	
